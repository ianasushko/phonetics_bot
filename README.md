# phonetics_bot
Бот для отработки артикуляционных характеристик звуков СРЛЯ

[ссылка на веб-страничку проекта](https://yanasushko5.wixsite.com/website)

# Что это?
Это код для telegram-бота.
Он выложен на Heroku и запускатся оттуда.

# Где запустить?
Адрес бота @pocket_knyzev_bot
Имя бота Фонетика Мяу

# Как запустить?
Правильные ответы можно понять из таблиц 
https://docs.google.com/document/d/13nUSpR7YQTwKvgjHUCWNmDXTxi22PfDflQxWM8Svt08/edit

# Теоретическая часть 
Звуки русского языка можно разделить на некоторые группы на основании общих признаков.
Принято выделять четыре группы:
место образования - каким органом выполняется артикуляция
способ образования - как ведут себя эти органы
дополнительная артикуляция - твердость/мягкость
фонация - глухость/звонкость 
На основании этих четырех признаков составлена таблица (ссылка выше)


# Несколько вводных слов 
common.py:
1. database - словарь, ключ - звук, значение - список характеристик.

2. Содержимое файла со всеми комментариями записывается в переменную comments
BIG_DICT - из json файла
Парсинг json и получение словарей C_PLACE, C_WAY, C_SOUNDNESS, C_EXTRA_ARTICULATION, RUS_LAT, ALL_CONSONANTS, ALT_NAMES

3. send_sound(sound): функция для отправки звуков голосовым сообщением.
Находит путь к файлу.
Открывает его (по дефолту питон читает сообщения как текстовые - "rb" - read binary.
Отправляет файл голосовым сообщением.
Если такой файл не находится (just in case), ничего не происходит.

# Порядок работы 
В main.py функция start получает на вход сообщение пользователя.
Если новый пользователь пишет, chat_id кладется в словарь session. 
@bot.middleware_handler обрабатывает каждое сообщение
Функция cancel_handler(): позволяет прерывать выполнение задания.
bot.clear_step_handler_by_chat_id(chat_id) - отменяет стэп хэндлерс, который ждет сообщения (ожидается ответ пользователя с данным chat_id, после чего вызывается следующий метод).

Выполняются методы, содержащиеся в классе Session. 

__init__(): конструктор класса, сюда кладутся переменные, актуальные для каждого класса: содержит список заданий, берет chat_id пользователя (@bot.message_handler(commands=['start'])) и отправляет сообщением слова вступления.

choose_grading_system(): отправляет сообщением варианты системы оценивания

process_task(): number_of_task - номер выбранного задания. Далее осуществляется проверка, подходящий ли ответ прислал пользователь. Выбранное задание сообщается функции run_task_five_times(), файл common.py
В common.py run_task_five_times() находится в классе Task (далее будем называть его Parent Task). Здесь задаются начальные параметры, которые будут обновляться после окончания этого задания при аналогичном запуске из main в reset. 

Вызов done(),
которая вызывает continue(): продолжается работа над заданием (если счетчик меньше 5) или вызывается done_five_times().
done_five_times()
error(): пользователю отправляются его ошибки
put_mark(): выставляется оценка по выбранной шкале
reset(): проверяет, создан ли список для сбора ошибок и создаёт его, если тот не существует.Создается список used (в заданиях некоторые элементы выбираются рандомно; в used кладутся уже использованные, чтобы избегать повтора элементов в игре),
 
В main.py после запуска задания 5 раз выполняется after_task_run(): after_task_run больше не None.
Тогда в done_five_times() она вызывается.
И отправляет обратно к choose_task, чтобы выбрать следующее задание.

ask_user(): удобная консоль
Берет список вариантов, располагает их так, что в каждом ряду заданное число символов (MAX_PER_ROW),
расстояние между двумя кнопками - 4 символа.
Представляет необходимые для задания (для ввода) характеристики.

Это, что происходит,если задание выполнено (count == 5). Иначе, выполняется выбранное задание. 

#  Несколько слов о каждом задании: 
Идея состоит в том, чтобы каждая функция вызывала последующую.

# task1
Это этом задании пользователю присылается звук. Нужно назвать место и способ его образования. 
В run_task записаны переменные, применимые ко всем объектам класса. Answer - правильный ответ на задание.
Вызывается get_place(): у пользователя спрашивается место артикуляции. 
bot.regester_next
Когда приходит первое сообщение, относящееся к этому заданию, от пользователя с таким chat_id.
Вызывается process_place():
Ответ пользователя обрабатывается функцией proceeding_input() (см. common.py) до того вида, в котором эти данные хранятся в json-файле.
Далее на ответы «не знаю» и «.» выводится правильный ответ.

Дело в том, что у некоторых фонетических терминов можно выделить синонимы. Чтобы программа понимала пользователя и не печатала «опечатка! попробуйте снова!», есть функция check_alternative_names() (см. common.py).:  она проверяет, содержится ли сообщение пользователя в словаре ALT_NAMES, и если да, «альтернативное» имя замещается на «стандартное», содержащееся в database. Если input не обычное имя, «альтернативное» и не «не знаю», то пользователю сообщается, что ответ введён с опечаткой и бот просит ввести ответ заново.
Далее answer, на который ответили «не знаю», добавляется в список mistakes.

Если ответ пользователя не опечатка, не не знаю — не все то, чего не содержится в database, то 
appropriate_sounds - список звуков, удовлетворяющих выбранным характеристикам (place and way). 
создается словарь count_place_way: 
{‘звук’:’число его вхождений’}. И отбирается правильный ответ:
 num_answer  == 2, правильный ответ входит в исходный список appropriate_sound дважды (см. клетки таблицы).
 
Бот отправляет сообщение пользователю: «Верно!» или «Неверно!».
Если ответ пользователя неправильный, он добавляется в mistakes.
Если же пользователь ответ пользователя в обоих случаях (и для места и для способа) был неверным, то бот пошлёт сообщение «Неверно!».

Далее запускается функция done, вызывающая continue_task():
Если задание было запущено меньше 5 раз, оно запускается:
см объяснение выше

reset() - добавляет ошибки пользователя в список past_mistakes — они пригодятся в функции get_answer() 
get_answer() работает так:
Проверяется длина списка past_mistakes. Она будет больше 0 при выполнении одного из следующих условий: ни одной ошибки не было было допущено или выполнения задания не завершено (не было запущено 5 раз). 
Если past_mistakes не пустой, то в следующий раз при запуске этого задания будет «работа над ошибками» — будут запускаться 
Вовращает одну из ошибок.
И отдает этот asnwer run_task()

Печать ошибок. Выставление оценки.

# task2
В этом задании бот печатает 4 характеристики звука и просит назвать звук.
Попасть в task2 можно точно так же, как и в task1.
get_user_answer(): выбирает список и печатает 4 характеристики.
Вызывается process_user_answer():
Сообщение пользователя обрабатывается уже известной proceeding_input(), 
Проверяется: если ответ пользователя это не звук из database или "не знаю", то на экран выводится сообщение об опечатки, и снова вызывается функция, принимающая ответ пользователя - get_user_answer().
Если ответ верный,
self.send_sound(self.answer) - отправляет звук голосовым сообщением
начисляет баллы.

Вызывается done(): как в task1.
done_five_times()

считает собранные в список mistakes ошибки и отправляет их сообщением.
past_mistakes - работа над ошибками

Печать ошибок. Выставление оценки.

# task3
В этом задании, как и в task2, бот печатает 4 характеристики и просит называть звук. 
Затем меняется одна из характеристик и снова нужно назвать звук.

Например:
заднеязычный задненебный, взрывной, без дополнительной артикуляции, глухой 
ответ [к]
заднеязычный задненебный, взрывной, без дополнительной артикуляции, звонкий
ответ [г]

(отличаются по глухости - звонкости)

Так, это задание можно разделить на 2 части:
1. повторяющее task2 (без выставления оценки)
2. изменяющее характеристику

Пункт 1 выполняется в методе run_task():
super(Task3, self).run_task(answer): запускает run_task в Parent Task для Task3, is_running_first_part = True.
Затем done() в Task3: is_running_first_part переприсваивается False.

Запускается ask_modified()
выбирается 1 из элементов текущего списка, его индекс (все элементы списка в database расположены в порядке, задаваемом при создании словаря, - место, способ,доп.артикуляция, фонация). Таким образом, по сохраняя индекс элемента, мы знаем, на какие характеристики элемент можно заменить. Возможные характеристики хранятся в списке available. Далее из available выбирается характеристика и начальный список значений модифицируется. 
Посмотрите в таблицу, данную в виду ссылки в начале файла. Из нее видно, что некоторые комбинации характеристик невозможны. И программа проверяет, существует ли звук с таким "модифицированным" набором характеристик.

Пользователь вводит ответ. 
process_user_answer_two(): обработка ответа, проверка на опечатки, вывод правильного ответа, начисление баллов.

Так как часть 1 task3 запускалась из task2, где за каждый верный ответ +2 балла,
После запуска 5 раз (счетчик), делим баллы на 2. 

done()
past_mistakes - работа над ошибками

Печать ошибок. Выставление оценки.

# task4
Задание состоит из 2х частей:
1. Дается русское название места артикуляции. Назвать латинское.
2. Дается соотношение латинское-русское. Проверить, верно ли соотношение.

Часть 1
Выбирается правильный ответ
continue_task(): проверяется, продолжать выполнять   часть 1   или перейти к   часть 2  (счетчик).
выбирается латинское название, обрабатывается, чтобы было понятно программе
На ответы "не знаю" отправляется answer,
При опечатке латинское название ( ask_latname() ) спрашивается еще раз.
Неправильные ответы добавляются в mistakes. Начисляются баллы.
done()
Первая часть запускается 5 раз ( continue_task()  ). Потом запускатся run_second_part().

Часть 2
"Распаковывается" tuple answer - русское и латинское название.
Печатается данное соотношение.
Обработка ответа на опечатки.
Верно или неверно. Баллы.
done()
past_mistakes - работа над ошибками

Печать ошибок. Выставление оценки.

После выполнения любого задания бот предалагает продолжить.

# bot
Есть два способа получения данных из интернета:
1. Постоянно спрашивать (polling)
2. Просить сервер посылать, если есть что-то новенькое (webhooks)


Вариант на Хероку не подходил, потому что в бесплатной версии страница будет реагировать на внешние сигналы, когда пользователь что-то делает. Бот работает по-другому, нужно знать что происходит с пользователем в каждый момент.

Простой сервер, на который webhook просит telegram посылать все сообщения (url heroku, где запущен код), решает эту проблему.
индекс запускается каждый раз, когда telegram видит, что это похоже на json. 
Преобразовывает json в словарь и отправляет боту, а он хэндлерам.

